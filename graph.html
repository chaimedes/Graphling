<html>
<head>
<title>Graphling</title>
<link rel="stylesheet" type="text/css" href="styles.css" />
<script src="Spot.js"></script>
<script src="Square.js"></script>
<script src="Utilities.js"></script>
<script>

var NODEW = 50;
var NODEH = 50;
var EDGEL = 20;
var CANW = 800; // The width for the drawing canvas
var CANH = 600; // The height for the drawing canvas
var curfx = CANW/2;
var curfy = CANH/2;
var curr = NODEW;
var cura = 0;

var ANIM_SPEED = 1000; // MS

// Returns the next free spot as defined by the addPhysicalVert() function.
function getFreeSpot() {
	return new Spot(curfx, curfy);
}

// Onload function. Set everything up.
window.onload = function() {

	// Set up the canvas
	var canv = document.getElementById("gcanvas");
	gcanvas.style.width=CANW + "px";
	gcanvas.style.height=CANH + "px";
	var ctx = canv.getContext("2d");
	
	var report = document.getElementById("report");
	
	function reportLine(text) {
		report.innerHTML = report.innerHTML + text + "<br />";
	}

	function reportSingle(text) {
		report.innerHTML = report.innerHTML + text;
	}
	
	
	// Define the Graph constructor.
	function Graph() {
		this.tickTimer = 0;
	}
	
	// Define the Graph prototype object.
	Graph.prototype = {
	
		// Holds the nodes
		verts: new Array(),
		
		// Holds the edges
		edges: new Array(),
		
		// Finds and returns the next free node ID
		getNewId:function() {
			var nid = 0;
			for (i in this.verts) {
				if (i >= nid) {
					nid++;
				}
			}
			return nid;
		},
		
		// Takes a node, returns true if it exists in this graph.
		nodeExists:function(node) {
			return this.nodeExistsById(node.nid);
		},
		
		// Takes the ID of a node, returns true if it exists in this graph.
		nodeExistsById:function(nodeid) {
			for (var n in this.verts) {
				if (n.nid == nodeid) {
					return true;
				}
			}
			return false;
		},
		
		// Creates a new node and adds it to the node list.
		addNode:function() {
			var idToUse = this.getNewId();
			var node = new Node(idToUse);
			this.verts.push(node);
			reportLine("Added new node with id " + idToUse + ".");
			return node;
		},
		
		// Remove a node from the graph safely.
		removeNode:function(id) {
			reportLine("Starting removal of node " + id + ".");
			var nok = this.verts[id];
			if (!nok) { return "Node " + id + " doesn't seem to exist."; }

			/* Hold the edges to delete until AFTER the entire iteration,
				because otherwise the array resizes and you miss edges. */
			var spliceList = new Array();
			for (var e = 0; e < this.edges.length; e++) {
				if (this.edges[e] != null && this.edges[e].n1.nid == id) {
					//this.disconnect(id, this.edges[e].n2.nid);
					    this.simpleDisconnect(e, spliceList);
				}
				if (this.edges[e] != null && this.edges[e].n2.nid == id) {
					//this.disconnect(id, this.edges[e].n1.nid);
					    this.simpleDisconnect(e, spliceList);
				}
			}
			for (var e1 = 0; e1 < spliceList.length; e1++) {
				this.edges.splice(spliceList[e1], 1);
			}
			this.verts.splice(id,1);
			//this.verts[id] == null;
			reportLine("Removed node " + id + ".");
		},
		getNode:function(nid) {
			for (var i in this.verts) {
				if (i.nid == nid) {
					return i;
				}
			}
		},
		
		// Connect two nodes with a new edge.
		// This function INTENTIONALLY does not check if the nodes are already connected.
		// That option is given to the user via the connected() function.
		connect:function(n1, n2) {
			var n1ok = this.verts[n1];
			var n2ok = this.verts[n2];
		    if (n1ok && n2ok) {
				this.edges.push(new Edge(n1ok, n2ok));
				return "Connecting " + n1 + " and " + n2 + ": success.<br />";
			}
			return "Node " + ((!n1ok)?n1:n2) + " doesn't seem to exist";
		},

		// Perform a simple disconnect by removing the specified edge.
		// No safety features.		
		simpleDisconnect:function(edge, sList) {
			reportSingle("Removing edge " + edge + "(" + this.edges[edge].n1.nid + ", " + this.edges[edge].n2.nid + ").");
			if (this.edges[edge] != null) {
				//alert("Edge " + edge + " has nodes " + this.edges[edge].n1.nid + " and " + this.edges[edge].n2.nid);
				this.edges[edge] = null;
				//this.edges.splice(edge, 1);
				sList.push(edge);
			}
			reportLine("...success.");
		},

		// Disconnect two nodes, removing their edge.
		// This function DOES check if the nodes are already connected.
		// However, it will report success for two nodes that weren't originally connected.
		disconnect:function(n1, n2) {
			var n1ok = this.verts[n1];
			var n2ok = this.verts[n2];
			if (n1ok && n2ok) {
				alert("Disconnecting " + n1 + " and " + n2 + ".");
				// Remove all connections that might exist
				for (var e = 0; e < this.edges.length; e++) {
					if ( (this.edges[e].n1.nid == n1 && this.edges[e].n2.nid == n2)	|| (this.edges[e].n1.nid == n2 || this.edges[e].n2.nid == n1) ) {
						this.edges[e] = null;
					}
				}
				return "Disconnecting " + n1 + " and " + n2 + ": success.";
			}
			return "Node " + ((!n1ok)?n2:n1) + " doesn't seem to exist";
		},
		
		// Check if two nodes are already connected.
		connected:function(n1, n2) {
			var n1ok = this.nodeExists(n1);
			var n2ok = this.nodeExists(n2);
			if (!n1ok || !n2ok) { return "Node " + (!n1ok?n2:n1) + " doesn't seem to exist"; }
			for (i in this.edges) {
				if ( (i.n1 == n1 && i.n2 == n2) || (i.n1 == n2 && i.n2 == n1) ) {
					return true;
				}
			}
			return false;
		},
		
		checkSpot:function() {
			for (var v = 0; v < this.verts.length; v++) {
				if (this.verts[v].entry != null) {
					if ((Math.sqrt(Math.pow((curfx-this.verts[v].entry.getX()),2) + Math.pow((curfy-this.verts[v].entry.getY()),2))) <= (NODEW + 20)) {
						return false;
					}
				}
			}
			return true;
		},
		
		// Update the actual drawing parameters based on adding a new vertex.
		addPhysicalVert:function() {
		
			var curSpot = getFreeSpot();
			
			// Right now, just update the free spot radially, moving slightly outward each time.
			// @TODO write a better way to place new nodes.
			curr += EDGEL;
			cura += (360 / this.verts.length);
			curfx = curr * Math.cos(cura*(Math.PI/180)) + CANW/2;
			curfy = curr * Math.sin(cura*(Math.PI/180)) + CANH/2;
			
			curfx = Math.floor(Math.random() * CANW);
			curfy = Math.floor(Math.random() * CANH);
			
			while (!this.checkSpot()) {
				curfx = Math.floor(Math.random() * CANW);
				curfy = Math.floor(Math.random() * CANH);
			}
			
			// Return the spot to place the new node.
			return new Square(curSpot.getX(), curSpot.getY(), NODEW, NODEH);
			
		},
		
		tetrahedral:function() {
			var self = this;
			for (var i = 0; i < 4; i++) {
				this.addNode();
			}
			for (var j = 0; j < this.verts.length; j++) {
				for (var k = 0; k < this.verts.length; k++) {
					if (j != k && !this.connected(j, k)) {
						setTimeout(function() {self.connect(j, k); self.draw(); }, 50);
					}
				}
			}
		},
		
		// Some really basic animation that works around the self-referencing timer problem.
		tick:function() {
			tickLimit = 10;
			var n = 0;
			if (this.tickTimer < tickLimit) {
				this.tickTimer++;
			}
			else { return; }
			if (this.tickTimer < tickLimit) {
				n = this.addNode();
				n.highlight(true);
				for (var j = 0; j < this.verts.length; j++) {
					if (n.nid != this.verts[j].nid) {
						n.highlight(false);
					}
				}
			}
			for (var j = 0; j < this.verts.length; j++) {
				for (var k = 0; k < this.verts.length; k++) {
					if (j != k && !this.connected(j, k)) {
						this.connect(j, k);
					}
				}
			}
			this.draw();
		},
		
		// Draw the graph itself
		draw:function() {
		
			// Clear the screen and reset the physical variables
			ctx.fillStyle="#FFFFFF";
			ctx.fillRect(0,0,CANW,CANH);
			//curfx = CANW/2;
			//curfy = CANH/2;
			curr = NODEW;
			cura = 0;

			// For every vertex...
			for (v in this.verts) {
				var vert = this.verts[v];
if (vert == null) { continue; }
				if (vert.entry == null) {
					vert.entry = this.addPhysicalVert();
				}
				vert.cx = vert.entry.getX() + (vert.entry.getW()/2);
				vert.cy = vert.entry.getY() + (vert.entry.getH()/2);
				ctx.fillStyle = "#444444";
				//ctx.fillRect(vert.entry.getX(), vert.entry.getY(), vert.entry.getW(), vert.entry.getH());
				ctx.beginPath();
				ctx.arc(vert.entry.getX()+vert.entry.getW()/2,vert.entry.getY()+vert.entry.getH()/2,vert.entry.getW()/2,0,2*Math.PI);
				ctx.fill(); 
				if (vert.isHighlighted()) {
					ctx.beginPath();
					ctx.strokeStyle = "#883";
					ctx.lineWidth = 3;
					ctx.arc(vert.entry.getX()+vert.entry.getW()/2,vert.entry.getY()+vert.entry.getH()/2,vert.entry.getW()/2,0,2*Math.PI);
					ctx.stroke();
				}
				ctx.lineWidth = 1;
				ctx.strokeStyle = "#000";
				ctx.fillStyle = "#FFFFFF";
				ctx.font = "18px Arial";
				ctx.fillText(vert.nid, vert.cx, vert.cy);
			}
			for (e in this.edges) {
				var edge = this.edges[e];
if (edge == null) { continue; }
				this.c = color();
				ctx.beginPath();
				ctx.strokeStyle="rgb(" + this.c.R + "," + this.c.G + "," + this.c.B + ")";
				ctx.moveTo(edge.n1.cx, edge.n1.cy);
				ctx.lineTo(edge.n2.cx, edge.n2.cy);
				/*
				var x = Math.pow((this.n2.cx - this.n1.cx), 2);
				var y = Math.pow((this.n2.cy - this.n1.cy), 2);
				var dist = Math.sqrt(x+			alert('looping');y);
				ctx.arcTo(this.n1.cx, this.n1.cy, this.n2.cx, this.n2.cy, dist);
				*/
				ctx.stroke();
			}
		} // End of draw()
		
	} // End of Graph prototype

	function Node(inid) {
		this.nid = inid;
		this.highlighted = false;

	} // End of Node constructor

	Node.prototype = {
	
		// Toggles the highlighting of this node (used by draw())
		highlight:function(toggle) {
			this.highlighted = toggle;
		},
		
		// Returns the value of the highlight toggle
		isHighlighted:function() {
			return this.highlighted;
		}
			
	} // End of Node prototype
	
	function Edge(in1, in2) {
		this.n1 = in1;
		this.n2 = in2;
	
	}

	Edge.prototype = {
	} // End of Edge prototype

	document.getElementById("addnode").addEventListener("click", function() {
	g.addNode();
	g.draw();
	});
	document.getElementById("connect").addEventListener("click", function() {
	report.innerHTML = report.innerHTML + "<br />" + g.connect(document.getElementById("v1").value, document.getElementById("v2").value);
	g.draw();
	});
	document.getElementById("delete").addEventListener("click", function() {
	g.removeNode(document.getElementById("vd").value);
	g.draw();
	});

/*
	var g = new Graph();
	for (var i = 0; i < 5; i++) {
		g.addNode();
	}
	*/
	var g = new Graph();
	//g.tetrahedral();
	window.setInterval(function() { g.tick(); }, ANIM_SPEED);
	//g.draw();

} // End of onload function

</script>
</head>
<body>
<div id="zone"></div>
<div id="controls">
<button id="addnode">Add Node</button><br />
<input type="text" id="v1" placeholder="ID of Vertex #1" />
<input type="text" id="v2" placeholder="ID of Vertex #2" />
<button id="connect">Connect</button><br />
<input type="text" id="vd" placeholder="ID of Vertex to Delete" />
<button id="delete">Delete</button>
</div><!-- End of controls div -->
<div id="report"></div>
<canvas id="gcanvas" width="800" height="600"></canvas>
</body>
</html>
