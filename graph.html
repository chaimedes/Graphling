<html>
<head>
<title>Graphling</title>
<link rel="stylesheet" type="text/css" href="styles.css" />
<script src="Spot.js"></script>
<script src="Square.js"></script>
<script src="Utilities.js"></script>
<script type="text/javascript" src="jquery-1.11.1.min.js"></script>
<script>

var NODEW = 50;
var NODEH = 50;
var EDGEL = 20;
var CANW = 800; // The width for the drawing canvas
var CANH = 600; // The height for the drawing canvas
var curfx = CANW/2;
var curfy = CANH/2;
var curr = NODEW;
var cura = 0;

var ANIM_SPEED = 1000; // MS

// Returns the next free spot as defined by the addPhysicalVert() function.
function getFreeSpot() {
	return new Spot(curfx, curfy);
}

// Onload function. Set everything up.
window.onload = function() {

	// Set up the canvas
	var canv = document.getElementById("gcanvas");
	gcanvas.style.width=CANW + "px";
	gcanvas.style.height=CANH + "px";
	var ctx = canv.getContext("2d");
	
	var report = document.getElementById("report");
	
	function reportLine(text) {
		report.innerHTML = report.innerHTML + text + "<br />";
	}

	function reportSingle(text) {
		report.innerHTML = report.innerHTML + text;
	}
	
	
	// Define the Graph constructor.
	function Graph() {
		this.tickTimer = 0;
		this.nodeSelected = -1;
	}
	
	// Define the Graph prototype object.
	Graph.prototype = {
	
		// Holds the nodes
		verts: new Array(),
		
		// Holds the edges
		edges: new Array(),
		
		// Finds and returns the next free node ID
		getNewId:function() {
			var nid = 0;
			for (i in this.verts) {
				if (i >= nid) {
					nid++;
				}
			}
			return nid;
		},
		
		// Takes a node, returns true if it exists in this graph.
		nodeExists:function(node) {
			return this.nodeExistsById(node.nid);
		},
		
		// Takes the ID of a node, returns true if it exists in this graph.
		nodeExistsById:function(nodeid) {
			for (var n in this.verts) {
				if (n.nid == nodeid) {
					return true;
				}
			}
			return false;
		},
		
		// Creates a new node and adds it to the node list.
		addNode:function() {
			var idToUse = this.getNewId();
			var node = new Node(idToUse);
			this.verts.push(node);
			reportLine("Added new node with id " + idToUse + ".");
			return node;
		},
		
		// Remove a node from the graph safely.
		removeNode:function(id) {
			reportLine("Starting removal of node " + id + ".");
			var nok = this.verts[id];
			if (!nok) { return "Node " + id + " doesn't seem to exist."; }

			/* Hold the edges to delete until AFTER the entire iteration,
				because otherwise the array resizes and you miss edges. */
			spliceList = new Array();
			for (var e = 0; e < this.edges.length; e++) {
				if (this.edges[e] != null && this.edges[e].n1.nid == id) {
					//this.disconnect(id, this.edges[e].n2.nid);
					    this.simpleDisconnect(e, spliceList);
				}
				if (this.edges[e] != null && this.edges[e].n2.nid == id) {
					//this.disconnect(id, this.edges[e].n1.nid);
					    this.simpleDisconnect(e, spliceList);
				}
			}
			for (var e1 = 0; e1 < spliceList.length; e1++) {
				reportLine("Removing edge " + spliceList[e1] + ".");
				this.edges.splice(spliceList[e1], 1);
			}
			this.verts.splice(id,1);
			//this.verts[id] == null;
			delete spliceList;
			reportLine("Removed node " + id + ".");
		},
		getNode:function(nid) {
			for (var i in this.verts) {
				if (i.nid == nid) {
					return i;
				}
			}
		},
		
		// Connect two nodes with a new edge.
		// This function INTENTIONALLY does not check if the nodes are already connected.
		// That option is given to the user via the connected() function.
		connect:function(n1, n2) {
			var n1ok = this.verts[n1];
			var n2ok = this.verts[n2];
		    if (n1ok && n2ok) {
				var temp = new Edge(n1ok, n2ok);
				temp.setText(Math.floor(Math.random()*5));
				this.edges.push(temp);
				reportLine("Connecting " + n1 + " and " + n2 + ": success.");
				return "Connecting " + n1 + " and " + n2 + ": success.<br />";
			}
			return "Node " + ((!n1ok)?n1:n2) + " doesn't seem to exist";
		},

		// Perform a simple disconnect by removing the specified edge.
		// No safety features.		
		simpleDisconnect:function(edge, sList) {
			reportSingle("Disconnecting edge " + edge + "(" + this.edges[edge].n1.nid + ", " + this.edges[edge].n2.nid + ").");
			if (this.edges[edge] != null) {
				this.edges[edge] = null;
				sList.push(edge);
			}
			reportLine("...success.");
		},

		// Disconnect two nodes, removing their edge.
		// This function DOES check if the nodes are already connected.
		// However, it will report success for two nodes that weren't originally connected.
		disconnect:function(n1, n2) {
			var n1ok = this.verts[n1];
			var n2ok = this.verts[n2];
			if (n1ok && n2ok) {
				alert("Disconnecting " + n1 + " and " + n2 + ".");
				// Remove all connections that might exist
				for (var e = 0; e < this.edges.length; e++) {
					if ( (this.edges[e].n1.nid == n1 && this.edges[e].n2.nid == n2)	|| (this.edges[e].n1.nid == n2 || this.edges[e].n2.nid == n1) ) {
						this.edges[e] = null;
					}
				}
				return "Disconnecting " + n1 + " and " + n2 + ": success.";
			}
			return "Node " + ((!n1ok)?n2:n1) + " doesn't seem to exist";
		},
		
		// Check if two nodes are already connected.
		connected:function(n1, n2) {
			var n1ok = this.nodeExists(n1);
			var n2ok = this.nodeExists(n2);
			if (!n1ok || !n2ok) { return "Node " + (!n1ok?n2:n1) + " doesn't seem to exist"; }
			for (i in this.edges) {
				if (this.edges[i] !== null) {
				if ( (this.edges[i].n1.nid == n1 && this.edges[i].n2.nid == n2) || (this.edges[i].n1.nid == n2 && this.edges[i].n2.nid == n1) ) {
					return true;
				}
				}
			}
			return false;
		},
		
		checkSpot:function() {
			for (var v = 0; v < this.verts.length; v++) {
				if (this.verts[v].entry != null) {
					if ((Math.sqrt(Math.pow((curfx-this.verts[v].entry.getX()),2) + Math.pow((curfy-this.verts[v].entry.getY()),2))) <= (NODEW + 20)) {
						return false;
					}
				}
			}
			return true;
		},
		
		// Update the actual drawing parameters based on adding a new vertex.
		addPhysicalVert:function() {
		
			var curSpot = getFreeSpot();
			
			// Right now, just update the free spot radially, moving slightly outward each time.
			// @TODO write a better way to place new nodes.
			curr += EDGEL;
			cura += (360 / this.verts.length);
			curfx = curr * Math.cos(cura*(Math.PI/180)) + CANW/2;
			curfy = curr * Math.sin(cura*(Math.PI/180)) + CANH/2;
			
			curfx = Math.floor(Math.random() * CANW);
			curfy = Math.floor(Math.random() * CANH);
			
			while (!this.checkSpot()) {
				curfx = Math.floor(Math.random() * CANW);
				curfy = Math.floor(Math.random() * CANH);
			}
			
			// Return the spot to place the new node.
			return new Square(curSpot.getX(), curSpot.getY(), NODEW, NODEH);
			
		},
		
		// Update the actual drawing parameters based on adding a new vertex.
		addPhysicalVertDefined:function(x, y) {
			
			// Get a random position
			curfx = Math.floor(Math.random() * CANW);
			curfy = Math.floor(Math.random() * CANH);
			
			// Check the position for collisions and update as many times as necessary.
			while (!this.checkSpot()) {
				curfx = Math.floor(Math.random() * CANW);
				curfy = Math.floor(Math.random() * CANH);
			}
			
			// Return the spot to place the new node.
			return new Square(x, y, NODEW, NODEH);
			
		}, // End of addPhysicalVertDefined(2)
		
		tetrahedral:function() {
			var self = this;
			for (var i = 0; i < 4; i++) {
				this.addNode();
			}
			for (var j = 0; j < this.verts.length; j++) {
				for (var k = 0; k < this.verts.length; k++) {
					if (j != k && !this.connected(j, k)) {
						setTimeout(function() {self.connect(j, k); self.draw(); }, 50);
					}
				}
			}
		},
		
		// Some really basic animation that works around the self-referencing timer problem.
		tick:function() {
			tickLimit = 10;
			var n = 0;
			if (this.tickTimer < tickLimit) {
				this.tickTimer++;
			}
			else { return; }
			if (this.tickTimer < 5) {
				n = this.addNode();
				n.highlight(true);
				for (var j = 0; j < this.verts.length; j++) {
					if (n.nid != this.verts[j].nid) {
						this.verts[j].highlight(false);
					}
				}
			}
			for (var j = 0; j < this.verts.length; j++) {
				for (var k = 0; k < this.verts.length; k++) {
					if (j != k && !this.connected(j, k)) {
						reportLine(j + " and " + k + " not connected yet.");
						this.connect(j, k);
					}
				}
			}
			this.draw();
		},
		
		highlightOnly:function(n) {
			n.highlight(true);
			for (var j = 0; j < this.verts.length; j++) {
				if (n.nid != this.verts[j].nid) {
					this.verts[j].highlight(false);
				}
			}
		},
		
		checkSpotForNode:function(x, y) {
			for (var v in this.verts) {
				if (this.verts[v].entry != null) {
					cx = this.verts[v].entry.getX() + (this.verts[v].entry.getW()/2);
					cy = this.verts[v].entry.getY() + (this.verts[v].entry.getH()/2);
					if ( (x < cx + (NODEW/2) && x > cx - (NODEW/2)) && (y < cy + (NODEW/2) && y > cy - (NODEW/2)) ) {
						return this.verts[v];
					}
				}
			}
			return false;
		},
		
		// Draw the graph itself
		draw:function() {
		
			// Clear the screen and reset the physical variables
			ctx.fillStyle="#FFFFFF";
			ctx.fillRect(0,0,CANW,CANH);
			//curfx = CANW/2;
			//curfy = CANH/2;
			curr = NODEW;
			cura = 0;

			// For every vertex...
			for (v in this.verts) {
			
				var vert = this.verts[v];
				// Skip this one if null
				if (vert == null) { continue; }
				// Otherwise, set up its physical properties. 
				if (vert.entry == null) {
					vert.entry = this.addPhysicalVert();
				}
				// Base calculations off the center of the node, for convenience.
				vert.cx = vert.entry.getX() + (vert.entry.getW()/2);
				vert.cy = vert.entry.getY() + (vert.entry.getH()/2);
				ctx.fillStyle = "#444444";
				//ctx.fillRect(vert.entry.getX(), vert.entry.getY(), vert.entry.getW(), vert.entry.getH());
				ctx.beginPath();
				ctx.arc(vert.entry.getX()+vert.entry.getW()/2,vert.entry.getY()+vert.entry.getH()/2,vert.entry.getW()/2,0,2*Math.PI);
				ctx.fill(); 
				if (vert.isHighlighted()) {
					ctx.beginPath();
					ctx.strokeStyle = "#ed4";
					ctx.lineWidth = 3;
					ctx.arc(vert.entry.getX()+vert.entry.getW()/2,vert.entry.getY()+vert.entry.getH()/2,vert.entry.getW()/2,0,2*Math.PI);
					ctx.stroke();
				}
				ctx.lineWidth = 1;
				ctx.strokeStyle = "#000";
				ctx.fillStyle = "#FFFFFF";
				ctx.font = "18px Arial";
				ctx.fillText(vert.nid, vert.cx, vert.cy);
			}
			
			// Iterate through the edges
			for (e in this.edges) {
			
				// Stroke each edge
				var edge = this.edges[e];
				if (edge == null) { continue; }
				this.c = color();
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.strokeStyle="rgb(" + edge.color.R + "," + edge.color.G + "," + edge.color.B + ")";
				ctx.moveTo(edge.n1.cx, edge.n1.cy);
				ctx.lineTo(edge.n2.cx, edge.n2.cy);
				ctx.stroke();
				
				//if (edge.edgeText != "") {
					ctx.fillStyle = "#000000";
					ctx.font = "15px Arial";
					ctx.fillText(edge.edgeText, edge.n1.cx + ((edge.n2.cx - edge.n1.cx)/2), edge.n1.cy + ((edge.n2.cy - edge.n1.cy)/2));
				//}
				
				// Start a new path to draw an arrow at the end of the edge, indicating direction
				// @TODO only if directional
				ctx.beginPath();
				rs = Math.sqrt(Math.pow(edge.n1.cx, 2) + Math.pow(edge.n1.cy, 2));
				ts = Math.atan(edge.n1.cy / edge.n1.cx);
				rd = Math.sqrt(Math.pow(edge.n2.cx, 2) + Math.pow(edge.n2.cy, 2));
				td = Math.atan(edge.n2.cy / edge.n2.cx);
				
				// Get angle of line from prev node to current node
				xDiff = edge.n2.cx - edge.n1.cx; 
				yDiff = edge.n2.cy - edge.n1.cy;
				ang = Math.atan2(yDiff, xDiff);
				
				// Draw arrow, thicker than rest of line.
				ctx.lineWidth = 4;
				ctx.lineTo(edge.n2.cx - 15*Math.cos(ang+.5), edge.n2.cy - 15*Math.sin(ang+.5));
				ctx.lineTo(edge.n2.cx, edge.n2.cy);
				ctx.lineTo(edge.n2.cx - 15*Math.cos(ang-.5), edge.n2.cy - 15*Math.sin(ang-.5));
				ctx.lineTo(edge.n2.cx, edge.n2.cy);
				ctx.stroke();
				ctx.lineWidth = 2;
				/*
				var x = Math.pow((this.n2.cx - this.n1.cx), 2);
				var y = Math.pow((this.n2.cy - this.n1.cy), 2);
				var dist = Math.sqrt(x+			alert('looping');y);
				ctx.arcTo(this.n1.cx, this.n1.cy, this.n2.cx, this.n2.cy, dist);
				*/
			
			} // End of for each edge
			
		} // End of draw()
		
	} // End of Graph prototype

	function Node(inid) {
		this.nid = inid;
		this.highlighted = false;

	} // End of Node constructor

	Node.prototype = {
	
		// Toggles the highlighting of this node (used by draw())
		highlight:function(toggle) {
			this.highlighted = toggle;
		},
		
		// Returns the value of the highlight toggle
		isHighlighted:function() {
			return this.highlighted;
		}
			
	} // End of Node prototype
	
	function Edge(in1, in2) {
		this.n1 = in1;
		this.n2 = in2;
		this.color = color();
		this.edgeText = "";
	}

	Edge.prototype = {
		setText:function(text) {
			this.edgeText = text;
		}
	} // End of Edge prototype

	document.getElementById("addnode").addEventListener("click", function() {
	g.addNode();
	g.draw();
	});
	document.getElementById("connect").addEventListener("click", function() {
	report.innerHTML = report.innerHTML + "<br />" + g.connect(document.getElementById("v1").value, document.getElementById("v2").value);
	g.draw();
	});
	document.getElementById("delete").addEventListener("click", function() {
	g.removeNode(document.getElementById("vd").value);
	g.draw();
	});

/*
	var g = new Graph();
	for (var i = 0; i < 5; i++) {
		g.addNode();
	}
	*/
	var g = new Graph();
	//g.tetrahedral();
	
	$("#gcanvas").mousedown(function(e) {
		spotX = e.pageX - $(this).offset().left;
		spotY = e.pageY - $(this).offset().top;
		if ((result = g.checkSpotForNode(spotX, spotY)) !== false) {
			result.isSelected = true;
			g.highlightOnly(result);
			g.nodeSelected = result;
		}
		g.draw();
	});
	
	$("#gcanvas").mouseup(function(e) {
		spotX = e.pageX - $(this).offset().left;
		spotY = e.pageY - $(this).offset().top;
		if ((result = g.checkSpotForNode(spotX, spotY)) == false) {
			if (g.nodeSelected !== -1) {
				g.nodeSelected.isSelected = false;
				g.nodeSelected.highlighted = false;
				//alert(g.nodeSelected.nid);
				g.nodeSelected.entry.setX(spotX);
				g.nodeSelected.entry.setY(spotY);
				g.nodeSelected = -1;
				g.draw();
			}
			else {
				var node = g.addNode();
				node.entry = g.addPhysicalVertDefined(spotX, spotY);
				g.draw();
			}
		}
	});
	/*
	$("#gcanvas").click(function(e) {
		node = g.addNode();
		spotX = e.pageX - $(this).offset().left;
		spotY = e.pageY - $(this).offset().top;
		node.entry = g.addPhysicalVertDefined(spotX, spotY);
		g.draw();
	});
	*/
	window.setInterval(function() { g.tick(); }, ANIM_SPEED);
	//g.draw();

} // End of onload function

</script>
</head>
<body>
<div id="zone"></div>
<div id="controls">
<button id="addnode">Add Node</button><br />
<input type="text" id="v1" placeholder="ID of Vertex #1" />
<input type="text" id="v2" placeholder="ID of Vertex #2" />
<button id="connect">Connect</button><br />
<input type="text" id="vd" placeholder="ID of Vertex to Delete" />
<button id="delete">Delete</button>
</div><!-- End of controls div -->
<div id="report"></div>
<canvas id="gcanvas" width="800" height="600"></canvas>
</body>
</html>
